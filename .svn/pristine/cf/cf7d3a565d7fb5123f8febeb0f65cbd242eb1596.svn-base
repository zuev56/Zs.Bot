using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Newtonsoft.Json.Linq;
using Telegram.Bot;
using Telegram.Bot.Args;
using Telegram.Bot.Exceptions;
using Telegram.Bot.Types;
using Telegram.Bot.Types.Enums;
using Zs.Bot.Helpers;
using Zs.Bot.Model.Db;
using Zs.Bot.Modules.Messaging;
using Zs.Common.Enums;
using Zs.Common.Modules;

namespace Zs.Bot.Telegram
{
    public class TelegramMessenger : ModuleBase, IMessenger
    {
        private readonly Logger _logger;

        // Количество попыток послать сообщение при неудаче
        private readonly int _trySendLimit = 5;

        /// <summary> Бот (модуль сторонней библиотеки) </summary>
        private TelegramBotClient _botClient;

        // Интервал между обработками сообщений из очереди
        private readonly int _messageProcessInterval = 1000;

        private readonly Buffer<InMessage> _inputMessageBuffer = new Buffer<InMessage>();
        private readonly Buffer<OutMessage> _outputMessageBuffer = new Buffer<OutMessage>();

        /// <summary> Обработка сообщений пользователей группового чата (не управляющих сообщений) </summary>
        public event Action<InMessage> GroupChatMessage_Handle;

        /// <summary> Вызывается после обработки сообщения. Параметры - ReturnAddress, MessageText </summary>
        public event Action<object, string> InputMessageProcessed;

        // Определяет необходимость сохранения в общий журнал информации от Telegram.Bot API
        public bool ApiLogIsEnabled { get; set; } = false;


        public TelegramMessenger(string token, IWebProxy webProxy = null)
        {
            _inputMessageBuffer.OnEnqueue  += InputMessageBuffer_OnEnqueue;
            _outputMessageBuffer.OnEnqueue += OutputMessageBuffer_OnEnqueue;

            _botClient = webProxy != null
                       ? new TelegramBotClient(token, webProxy)
                       : new TelegramBotClient(token);

            _botClient.IsReceiving = true;
            _botClient.Timeout     = TimeSpan.FromMilliseconds(5000);

            _botClient.ApiResponseReceived   += BotClient_ApiResponseReceived;
            _botClient.OnCallbackQuery       += BotClient_OnCallbackQuery;
            _botClient.OnInlineQuery         += BotClient_OnInlineQuery;
            _botClient.OnInlineResultChosen  += BotClient_OnInlineResultChosen;
            _botClient.OnMessage             += BotClient_OnMessage;
            _botClient.OnMessageEdited       += BotClient_OnMessageEdited;
            _botClient.OnReceiveError        += BotClient_OnReceiveError;
            _botClient.OnReceiveGeneralError += BotClient_OnReceiveGeneralError;
            _botClient.OnUpdate              += BotClient_OnUpdate;

            _botClient.StartReceiving(new UpdateType[]
                {
                    UpdateType.CallbackQuery,
                    UpdateType.ChannelPost,
                    UpdateType.ChosenInlineResult,
                    UpdateType.EditedChannelPost,
                    UpdateType.EditedMessage,
                    UpdateType.InlineQuery,
                    UpdateType.Message,
                    UpdateType.PreCheckoutQuery,
                    UpdateType.ShippingQuery,
                    UpdateType.Unknown
                });
        }

        //public override void Start(int delay)
        //{
        //    try
        //    {
        //        _botClient.StartReceiving(new UpdateType[]
        //        {
        //            UpdateType.CallbackQuery,
        //            UpdateType.ChannelPost,
        //            UpdateType.ChosenInlineResult,
        //            UpdateType.EditedChannelPost,
        //            UpdateType.EditedMessage,
        //            UpdateType.InlineQuery,
        //            UpdateType.Message,
        //            UpdateType.PreCheckoutQuery,
        //            UpdateType.ShippingQuery,
        //            UpdateType.Unknown
        //        });
        //    }
        //    catch (Exception ex)
        //    {
        //        _logger.LogError(ex);
        //    }
        //}

        //public override void Stop(int delay = 0)
        //{
        //    _botClient.StopReceiving();
        //
        //    //// Очистка очередей
        //    //_inputMessageBuffer = new Buffer<InMessage>();
        //    //_outputMessageBuffer = new Buffer<OutMessage>();
        //}

        #region Обработчики событий TelegramBotClient

        private void BotClient_ApiResponseReceived(object sender, ApiResponseEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.LogInfo("ApiResponseReceived", e.ResponseMessage, "Telegram.Bot.API");
        }

        private void BotClient_MakingApiRequest(object sender, ApiRequestEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.LogInfo("MakingApiRequest", e, "Telegram.Bot.API");
        }

        /// <summary> Обработчик нажатия кнопок </summary>
        private void BotClient_OnCallbackQuery(object sender, CallbackQueryEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.LogInfo("OnCallbackQuery", e, "Telegram.Bot.API");
        }

        private void BotClient_OnInlineQuery(object sender, InlineQueryEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.LogInfo("OnInlineQuery", e, "Telegram.Bot.API");
        }

        private void BotClient_OnInlineResultChosen(object sender, ChosenInlineResultEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.LogInfo("OnInlineResultChosen", e, "Telegram.Bot.API");
        }

        /// <summary> Обработчик входящих сообщений</summary>
        private void BotClient_OnMessage(object sender, MessageEventArgs e)
        {
            try
            {
                if (ApiLogIsEnabled)
                    _logger.LogInfo("OnMessage", e, "Telegram.Bot.API");

                _inputMessageBuffer.Enqueue(new InMessage(e.Message));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Не удалось поместить входящее сообщение в буфер. TelegramMessageId={e?.Message?.MessageId}");
            }
        }

        private void BotClient_OnMessageEdited(object sender, MessageEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.LogInfo("OnMessageEdited", e, "Telegram.Bot.API");
        }

        private void BotClient_OnReceiveError(object sender, ReceiveErrorEventArgs e)
        {
            if (e?.ApiRequestException?.Message != "Request timed out")
                _logger.LogInfo("OnReceiveError", e, "Telegram.Bot.API");
        }

        private void BotClient_OnReceiveGeneralError(object sender, ReceiveGeneralErrorEventArgs e)
        {
            if (e.Exception is System.Net.Http.HttpRequestException)
                return;

            _logger.LogInfo("OnReceiveGeneralError", e, "Telegram.Bot.API");
        }

        private void BotClient_OnUpdate(object sender, UpdateEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.LogInfo("OnUpdate", e, "Telegram.Bot.API");
        }

        #endregion
      
        /// <summary> Активация обработчика входящих сообщений </summary>
        private void InputMessageBuffer_OnEnqueue(object sender, InMessage item)
        {
            Task.Run(() => ProcessInputMessages());
        }

        /// <summary> Активация обработчика исходящих сообщений </summary>
        private void OutputMessageBuffer_OnEnqueue(object sender, OutMessage item)
        {
            Task.Run(() => ProcessOutputMessages());
        }
      
        /// <summary> Обработчик очереди входящих сообщений </summary>
        private void ProcessInputMessages()
        {
            InMessage msgForLog = null; // получаем ссылку на сообщение для передачи в лог

            try
            {
                while (_inputMessageBuffer.TryDequeue(out InMessage tgMessage))
                {
                    msgForLog = tgMessage;

                    // Сохраняем данные сообщения
                    //  var dbReceivedMessage = ConvertToReceivedMessage(tgMessage);
                    //  if (!DbReceivedMessage.SaveToDb(dbReceivedMessage))
                    //      throw new InvalidOperationException("Не удалось сохранить входящее сообщение в БД");

                    // Если это групповой чат, то, сохранив сообщение, выходим
                    // НО т.о. бот не будет обрабатывать команды из такого чата
                    if (tgMessage.Chat.Type != ChatType.Private)
                    {
                        GroupChatMessage_Handle?.Invoke(tgMessage);
                        continue;
                    }

                    //0. Находим сессию или создаём новую
                    //DbSession session = null;
                    //using (var ctx = new RobotDbContext())
                    //{
                    //    session = ctx.Sessions.FirstOrDefault(s => s.ChatId == tgMessage.Chat.Id);
                    //
                    //    if (session == null)
                    //    {
                    //        session = new DbSession
                    //        {
                    //            ChatId = tgMessage.Chat.Id,
                    //            SessionIsLoggedIn = false,
                    //            InsertDate = DateTime.Now,
                    //            UpdateDate = DateTime.Now
                    //        };
                    //        ctx.Sessions.Add(session);
                    //        ctx.SaveChanges();
                    //    }
                    //}

                    // Обрабатываем в вышестоящем классе
                    InputMessageProcessed.Invoke(tgMessage.Chat.Id, tgMessage.Text);

                    msgForLog = null;
                }
            }
            catch (Exception ex)
            {
                ex.Data.Add("MessageId", msgForLog?.MessageId);
                _logger.LogError(ex);
            }

        }

        /// <summary> Обработчик очереди исходящих сообщений </summary>
        private async Task ProcessOutputMessages()
        {
            OutMessage msgForLog = null;
            try
            {
                while (_outputMessageBuffer.TryDequeue(out OutMessage tgMessage))
                {
                    msgForLog = tgMessage;
                    using var ctx = new RobotDbContext();
                        await SendMessageFinaly(tgMessage).ConfigureAwait(false);

                    msgForLog = null;
                }
            }
            catch (Exception ex)
            {
                ex.Data.Add("MessageId", msgForLog?.MessageId);
                _logger.LogError(ex);
            }
                       
        }
      

        /// <summary> Добавление сообщения в очередь на отправку </summary>
        private void AddMessageToOutbox(Chat chat, string message, string tag = null, int replyToMessageId = -1)
        {
            var tgMsg = new OutMessage(chat, message) { Tag = tag };
            if (replyToMessageId != -1)
                tgMsg.ReplyToMessageId = replyToMessageId;

            _outputMessageBuffer.Enqueue(tgMsg);
        }

        /// <summary> Удаление сообщения из чата </summary>
        public bool DeleteMessage(long chatId, int messageId)
        {
            try
            {
                //_botClient.DeleteMessageAsync(chatId, messageId);
                //
                //// Меняем значение IsDeleted в обеих таблицах
                //using var ctx = new RobotDbContext();
                //var inMsg = ctx.ReceivedMessages.FirstOrDefault(m => m.ChatId == chatId
                //                  && m.ReceivedMsgMessageId == messageId);
                //
                //var outMsg = ctx.SentMessages.FirstOrDefault(m => m.ChatId == chatId
                //                  && m.SentMsgMessageId == messageId);
                //
                //if (inMsg != null)
                //    inMsg.IsDeleted = true;
                //
                //if (outMsg != null)
                //    outMsg.IsDeleted = true;
                //
                //ctx.SaveChanges();

                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex);
                return false;
            }
        }



        /// <summary> Отправка сообщения пользователю (главный, конечный шаг) </summary>
        private async Task SendMessageFinaly(OutMessage tgMessage)
        {
            string tmpFilePath = null;
            try
            {
                Message tmp = null;

                // Определяем тип сообщения, наличие клавиатуры и т.д., а потом уже формируем сообщение и отправляем
                if (tgMessage.Type == MessageType.Text)
                {
                    // Необходимо, чтобы не словить исключение
                    if (string.IsNullOrWhiteSpace(tgMessage.Text))
                        throw new Exception("Сообщение для пользователя должно содержать хоть какой-то текст!");
                
                    //if (tgMessage.Message_InlineKeyboard != null)
                    //    await _botClient.SendTextMessageAsync(tgMessage.Chat.Id, $"Пока не умею отсылать сообщения с клавиатурой {tgMessage.GetKeyboardType()}. Сообщите об этом разработчику");
                    //else if (tgMessage.Message_ReplyKeyboard != null)
                    //{
                    //    var markup = GetReplyKeyboardMarkup(tgMessage.Message_ReplyKeyboard);
                    //    await _botClient.SendTextMessageAsync(tgMessage.Chat.Id, tgMessage.Text, ParseMode.Default, replyMarkup: markup);
                    //}
                    //else
                    //    await _botClient.SendTextMessageAsync(tgMessage.Chat.Id, tgMessage.Text, parseMode:ParseMode.Markdown);
                
                    // Просто отправляем или отправляем ответ на сообщение
                    if (tgMessage.ReplyToMessageId == null || tgMessage.ReplyToMessageId == -1)
                        tmp = new OutMessage(await _botClient.SendTextMessageAsync(tgMessage.Chat.Id, tgMessage.Text, parseMode: ParseMode.Markdown).ConfigureAwait(true));
                    else
                        tmp = new OutMessage(await _botClient.SendTextMessageAsync(tgMessage.Chat.Id, tgMessage.Text, parseMode: ParseMode.Markdown, replyToMessageId: (int)tgMessage.ReplyToMessageId).ConfigureAwait(true));
                
                }
                else if (tgMessage.Type == MessageType.Document)
                {
                    //throw new NotImplementedException();
                    //tmpFilePath = GetLocalFileCopy(tgMessage.Message_FilePath);
                    ////Monitor.Enter(_lockObject_SendFile);
                    //using (var fileStream = new FileStream(tmpFilePath, FileMode.Open))
                    //{
                    //    var file = new InputOnlineFile(fileStream);
                    //    await _botClient.SendDocumentAsync(tgMessage.Chat.Id, file, tgMessage.Text);
                    //}
                    ////Monitor.Exit(_lockObject_SendFile);
                
                }
                else
                {
                    await _botClient.SendTextMessageAsync(tgMessage.Chat.Id, $"Пока не умею отсылать сообщения с типом {tgMessage.Type}. Сообщите об этом разработчику").ConfigureAwait(true);
                }
                
                // Сохраняем данные сообщения в БД
                if (tmp != null)
                {
                    tgMessage.Parse(tmp);
                    //tgMessage.GetMessageId?.Invoke();
                    tgMessage.IsSentSuccessfully = true;
                    await SaveSentMessageToDb(tgMessage).ConfigureAwait(false);
                }
            }
            catch (Exception ex)
            {
                // Если не удалось отправить сообщения из-за таймаута 
                if (ex is ApiRequestException)
                {// Плохо, но немного лучше чем постоянное дублирование

                    if (tgMessage.FailedSendings > 1)
                    {              // Даём только 2 попытки и выходим
                        try
                        {
                            // Сохраняем данные сообщения в БД
                            tgMessage.IsSentSuccessfully = false;
                            await SaveSentMessageToDb(tgMessage).ConfigureAwait(true);
                        }
                        catch { }

                        //await _logger.SaveExceptionAsync(ex);
                        //_logger.SaveToDb("ОШИБКА! Отправка сообщения", ex, tgMessage?.MessageId);
                        return;
                    }
                    else
                        Thread.Sleep(5000);  // После первого сбоя засыпаем на 5 секунд
                }

                // Пытаемся три раза отправить сообщение, прежде чем вылетит эксепшн
                if (tgMessage.FailedSendings < _trySendLimit)
                {
                    tgMessage.FailDescription = $"{ex.Message}\n{ex.StackTrace}";
                    tgMessage.FailedSendings++;
                    Thread.Sleep(1000 * 2 * tgMessage.FailedSendings);
                    _outputMessageBuffer.Enqueue(tgMessage);
                }
                else
                {
                    try
                    {
                        // Сохраняем данные сообщения в БД
                        tgMessage.IsSentSuccessfully = false;
                        await SaveSentMessageToDb(tgMessage).ConfigureAwait(true);
                        ex.Data.Add("MessageId", tgMessage?.MessageId);
                        _logger.LogError(ex);
                    }
                    catch { }

                    //await _logger.SaveExceptionAsync(ex);
                    //_logger.SaveToDb("ОШИБКА! Отправка сообщения", ex);
                }
            }
            finally
            {
                // Убираем мусор
                if (System.IO.File.Exists(tmpFilePath))
                    System.IO.File.Delete(tmpFilePath);
            }

        }
      
        /// <summary> Сохранение сообщения для пользователея в БД </summary>
        private async Task SaveSentMessageToDb(OutMessage tgMessage)
        {
            //try
            //{
            //    if (!await DbSentMsg.SaveToDbAsync(tgMessage).ConfigureAwait(true))
            //        throw new Exception("Не удалось сохранить исходящее сообщение в БД");
            //}
            //catch (Exception ex)
            //{
            //    //await _logger.SaveExceptionAsync(ex);
            //    _logger.SaveToDb("ОШИБКА! Сохранение отправленного сообщения в БД", ex);
            //}
        }

        public void AddMessageToOutbox(IDbChat chat, string messageText, string tag = null, int replyToMessageId = -1)
        {
            throw new NotImplementedException();
        }

        public void AddMessageToOutbox(string messageText, params string[] userRoleCodes)
        {
            using var ctx = new RobotDbContext();
            var users = ctx.Users.Where(u => userRoleCodes.Contains(u.UserRoleCode))
                                    .ToList();// Для исключения Npgsql.NpgsqlOperationInProgressException: A command is already in progress

            var chats = ctx.Chats.Where(c => users.Select(u => u.UserId).Contains(c.ChatId)).ToList();

            var tgChats = chats.Select(c => JsonSerializer.Deserialize<Chat>(c.RawData));
            
            foreach (var chat in tgChats)
                _outputMessageBuffer.Enqueue(new OutMessage(chat, messageText));

            var testTgChat = new Chat()
            {
                Id = 210281448
            };
            _outputMessageBuffer.Enqueue(new OutMessage(testTgChat, messageText));
        }

        public IDbReceivedMessage ConvertToReceivedMessage(object specificMessage)
        {
            var telegramMessage = (Message)specificMessage;
            var receivedMessage = MessageFactory.NewReceivedMessage();

            receivedMessage.ChatId = -11; //!!!
            receivedMessage.UserId = -11; //!!!
            // receivedMessage.ReceivedMessageId -> Auto
            receivedMessage.MessengerCode = "TG";
            receivedMessage.MessageTypeCode = GetGeneralTypeCode(telegramMessage.Type);
            receivedMessage.ReceivedMessageText = telegramMessage.Text;
            receivedMessage.RawData = JsonSerializer.Serialize(telegramMessage);

            return receivedMessage;
        }
        public IDbSentMessage ConvertToSentMessage(object specificMessage)
        {
            var telegramMessage = (Message)specificMessage;
            var sentMessage = MessageFactory.NewSentMessage();

            sentMessage.ChatId = -11; //!!!
            sentMessage.UserId = -11; //!!!
            // sentMessage.SentMessageId -> Auto
            sentMessage.MessengerCode = "TG";
            sentMessage.MessageTypeCode = GetGeneralTypeCode(telegramMessage.Type);
            sentMessage.SentMessageText = telegramMessage.Text;
            sentMessage.RawData = JsonSerializer.Serialize(telegramMessage);

            return sentMessage;
        }

        private string GetGeneralTypeCode(MessageType type)
        {
            return type switch
            {
                MessageType.Text     => "TXT",
                MessageType.Photo    => "PHT",
                MessageType.Audio    => "AUD",
                MessageType.Video    => "VID",
                MessageType.Voice    => "VOI",
                MessageType.Document => "DOC",
                MessageType.Sticker  => "STK",
                MessageType.Location => "LOC",
                MessageType.Contact  => "CNT",

                var o when
                o == MessageType.Venue ||
                o == MessageType.Game ||
                o == MessageType.VideoNote ||
                o == MessageType.Invoice ||
                o == MessageType.SuccessfulPayment ||
                o == MessageType.WebsiteConnected ||
                o == MessageType.Animation ||
                o == MessageType.Poll ||
                o == MessageType.Dice => "OTH",

                var s when
                s == MessageType.ChatMembersAdded ||
                s == MessageType.ChatMemberLeft ||
                s == MessageType.ChatTitleChanged ||
                s == MessageType.ChatPhotoChanged ||
                s == MessageType.MessagePinned ||
                s == MessageType.ChatPhotoDeleted ||
                s == MessageType.GroupCreated ||
                s == MessageType.SupergroupCreated ||
                s == MessageType.ChannelCreated ||
                s == MessageType.MigratedToSupergroup ||
                s == MessageType.MigratedFromGroup => "SRV",

                _ => "UKN"
            };
        }

    }
}
