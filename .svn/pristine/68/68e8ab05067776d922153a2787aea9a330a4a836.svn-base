using System;
using System.Linq;
using System.Net;
using System.Threading;
using System.Threading.Tasks;
using Telegram.Bot;
using Telegram.Bot.Args;
using Telegram.Bot.Types;
using Telegram.Bot.Types.Enums;
using Zs.Bot.DbModel;
using Zs.Bot.Helpers;
using Zs.Common.Enums;
using Zs.Common.Modules;

namespace Zs.Bot.Modules.Messaging//.Telegram
{
    /// <summary>
    /// 
    /// </summary>
    public class TelegramMessenger : ModuleBase, IMessanger
    {
        private readonly Logger _logger;

        // Количество попыток послать сообщение при неудаче
        private readonly int _trySendLimit = 5;

        private static TelegramMessenger _instance;

        /// <summary> Бот (модуль сторонней библиотеки) </summary>
        private TelegramBotClient _botClient;

        private readonly ManualResetEvent _mreInputMsgProcessor = new ManualResetEvent(true);
        private readonly ManualResetEvent _mreOutputMsgProcessor = new ManualResetEvent(true);

        // Интервал между обработками сообщений из очереди
        private readonly int _messageProcessInterval = 1000;

        // Потоки
        private readonly Thread _inputMsgProcessorThread;
        private readonly Thread _outputMsgProcessorThread;

        // Буферы сообщений
        private Buffer<InMessage> _inputMessageBuffer = new Buffer<InMessage>();
        private Buffer<OutMessage> _outputMessageBuffer = new Buffer<OutMessage>();

        /// <summary> Обработка сообщений пользователей группового чата (не управляющих сообщений) </summary>
        public event Action<InMessage> GroupChatMessage_Handle;

        /// <summary> Вызывается после обработки сообщения. Параметры - ReturnAddress, MessageText </summary>
        public event Action<object, string> InputMessageProcessed;


        // Определяет необходимость сохранения в общий журнал информации от Telegram.Bot API
        public bool ApiLogIsEnabled { get; set; } = false;



        protected TelegramMessenger()
        {
            _inputMessageBuffer.OnEnqueue  += InputMessageBuffer_OnEnqueue;
            _outputMessageBuffer.OnEnqueue += OutputMessageBuffer_OnEnqueue;

            _inputMsgProcessorThread  = new Thread(ProcessInputMessages)  { Name = "InputMessageProcessorThread" };
            _outputMsgProcessorThread = new Thread(ProcessOutputMessages) { Name = "OutputMessageProcessorThread" };
            
        }


        public static TelegramMessenger GetInstance()
        {
            if (_instance == null)
                throw new InvalidOperationException($"Объект {nameof(TelegramMessenger)} не инициализирован! Сначала необходимо вызвать метод {nameof(Initialize)}");

            return _instance;
        }

        /// <summary> Инициализация TelegramMessenger </summary>
        /// <param name="token"></param>
        /// <param name="webProxy"></param>
        public static void Initialize(string token, IWebProxy webProxy = null)
        {
            if (_instance != null)
                throw new InvalidOperationException($"Недопустима повторная инициализация {nameof(TelegramMessenger)}!");

            _instance = new TelegramMessenger
            {
                _botClient = webProxy != null
                           ? new TelegramBotClient(token, webProxy)
                           : new TelegramBotClient(token)
            };

            _instance._botClient.IsReceiving = true;
            _instance._botClient.Timeout     = TimeSpan.FromMilliseconds(5000);

            _instance._botClient.ApiResponseReceived   += _instance.BotClient_ApiResponseReceived;
            _instance._botClient.OnCallbackQuery       += _instance.BotClient_OnCallbackQuery;
            _instance._botClient.OnInlineQuery         += _instance.BotClient_OnInlineQuery;
            _instance._botClient.OnInlineResultChosen  += _instance.BotClient_OnInlineResultChosen;
            _instance._botClient.OnMessage             += _instance.BotClient_OnMessage;
            _instance._botClient.OnMessageEdited       += _instance.BotClient_OnMessageEdited;
            _instance._botClient.OnReceiveError        += _instance.BotClient_OnReceiveError;
            _instance._botClient.OnReceiveGeneralError += _instance.BotClient_OnReceiveGeneralError;
            _instance._botClient.OnUpdate              += _instance.BotClient_OnUpdate;
        }

        public override void Start(int delay)
        {
            try
            {
                _botClient.StartReceiving(new UpdateType[]
                {
                    UpdateType.CallbackQuery,
                    UpdateType.ChannelPost,
                    UpdateType.ChosenInlineResult,
                    UpdateType.EditedChannelPost,
                    UpdateType.EditedMessage,
                    UpdateType.InlineQuery,
                    UpdateType.Message,
                    UpdateType.PreCheckoutQuery,
                    UpdateType.ShippingQuery,
                    UpdateType.Unknown
                });

                _inputMsgProcessorThread.IsBackground = true;
                _outputMsgProcessorThread.IsBackground = true;
                _inputMsgProcessorThread.Start();
                _outputMsgProcessorThread.Start();

            }
            catch (Exception ex)
            {
                _logger.SaveToDb("ОШИБКА! Запуск бота", ex);
            }
        }

        public override void Stop(int delay = 0)
        {
            _botClient.StopReceiving();

            // Очистка очередей
            _inputMessageBuffer = new Buffer<InMessage>();
            _outputMessageBuffer = new Buffer<OutMessage>();
        }

        #region Обработчики событий TelegramBotClient

        private void BotClient_ApiResponseReceived(object sender, ApiResponseEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.SaveToDb(LogType.Info, "API", e.ResponseMessage.Content.ToString());
        }

        private void BotClient_MakingApiRequest(object sender, ApiRequestEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.SaveToDb(LogType.Info, "API", e.HttpContent.Headers.ToString());
        }

        /// <summary> Обработчик нажатия кнопок </summary>
        private void BotClient_OnCallbackQuery(object sender, CallbackQueryEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.SaveToDb(LogType.Info, "API", e.CallbackQuery.Data);
        }

        private void BotClient_OnInlineQuery(object sender, InlineQueryEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.SaveToDb(LogType.Info, "API", e.InlineQuery.Query);
        }

        private void BotClient_OnInlineResultChosen(object sender, ChosenInlineResultEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.SaveToDb(LogType.Info, "API", e.ChosenInlineResult.Query);
        }

        /// <summary> Обработчик входящих сообщений</summary>
        private void BotClient_OnMessage(object sender, MessageEventArgs e)
        {
            try
            {
                // Помещаем сообщение в буфер. Пробуждение потока происходит в обработчике события, возникающего при добавлении элемента в очередь
                _inputMessageBuffer.Enqueue(new InMessage(e.Message));
            }
            catch (Exception ex)
            {
                _logger.SaveToDb("Не удалось поместить входящее сообщение в буфер!", ex, e.Message.MessageId);
            }

        }

        private void BotClient_OnMessageEdited(object sender, MessageEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.SaveToDb(LogType.Info, "API", $"{e.Message.MessageId}");
        }

        private void BotClient_OnReceiveError(object sender, ReceiveErrorEventArgs e)
        {
            if (e?.ApiRequestException?.Message != "Request timed out")
                _logger.SaveToDb("ОШИБКА! ApiRequestException", e.ApiRequestException);
        }

        private void BotClient_OnReceiveGeneralError(object sender, ReceiveGeneralErrorEventArgs e)
        {
            if (e.Exception is System.Net.Http.HttpRequestException)
                return;

            _logger.SaveToDb("ОШИБКА! ...", e.Exception);
        }

        private void BotClient_OnUpdate(object sender, UpdateEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.SaveToDb(LogType.Info, "API", e.Update.PreCheckoutQuery.ToString());
        }

        #endregion
        
        /// <summary> Активация обработчика входящих сообщений </summary>
        private void InputMessageBuffer_OnEnqueue(object sender, InMessage item)
        {
            _mreInputMsgProcessor.Set();
        }

        /// <summary> Активация обработчика исходящих сообщений </summary>
        private void OutputMessageBuffer_OnEnqueue(object sender, OutMessage item)
        {
            _mreOutputMsgProcessor.Set();
        }
        
        /// <summary> Обработчик очереди входящих сообщений </summary>
        private void ProcessInputMessages()
        {
            try
            {
                InMessage msgForLog = null; // получаем ссылку на сообщение для передачи в лог

                while (true)
                {
                    try
                    {
                        // Если буфер пустой, приостанавливаем поток
                        if (_inputMessageBuffer.IsEmpty)
                            _mreInputMsgProcessor.Reset();

                        // Ждём вызова Set() -- ???
                        _mreInputMsgProcessor.WaitOne(Timeout.Infinite);


                        while (_inputMessageBuffer.TryDequeue(out InMessage tgMessage))
                        {
                            msgForLog = tgMessage;

                            // Сохраняем данные сообщения
                            if (!DbReceivedMsg.SaveToDb(tgMessage))
                                throw new InvalidOperationException("Не удалось сохранить входящее сообщение в БД");

                            // Если это групповой чат, то, сохранив сообщение, выходим
                            // НО т.о. бот не будет обрабатывать команды из такого чата
                            if (tgMessage.Chat.Type != ChatType.Private)
                            {
                                GroupChatMessage_Handle?.Invoke(tgMessage);
                                continue;
                            }

                            //0. Находим сессию или создаём новую
                            DbSession session = null;
                            using (var ctx = new ZsBotContext())
                            {
                                session = ctx.Sessions.FirstOrDefault(s => s.ChatId == tgMessage.Chat.Id);

                                if (session == null)
                                {
                                    session = new DbSession
                                    {
                                        ChatId = tgMessage.Chat.Id,
                                        SessionIsLoggedIn = false,
                                        InsertDate = DateTime.Now,
                                        UpdateDate = DateTime.Now
                                    };
                                    ctx.Sessions.Add(session);
                                    ctx.SaveChanges();
                                }
                            }

                            // Обрабатываем в вышестоящем классе
                            InputMessageProcessed.Invoke(tgMessage.Chat.Id, tgMessage.Text);

                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.SaveToDb("Ошибка обработки очереди входящих сообщений", ex, msgForLog.MessageId);
                    }
                    finally
                    {
                        msgForLog = null;

                        // Немного ждём прежде чем перейдём к обработке следующего сообшения
                        _mreInputMsgProcessor.WaitOne(_messageProcessInterval);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.SaveToDb("Покинут метод обработки входящих сообщений", ex);
            }
        }

        /// <summary> Обработчик очереди исходящих сообщений </summary>
        private async void ProcessOutputMessages()
        {
            OutMessage msgForLog = null; // получаем ссылку на сообщение для передачи в лог
            while (true)
            {
                try
                {
                    // Если буфер пустой, приостанавливаем поток
                    if (_outputMessageBuffer.IsEmpty)
                        _mreOutputMsgProcessor.Reset();


                    _mreOutputMsgProcessor.WaitOne(Timeout.Infinite);


                    while (_outputMessageBuffer.TryDequeue(out OutMessage tgMessage))
                    {
                        msgForLog = tgMessage;
                        using var ctx = new ZsBotContext();
                        if (tgMessage.Chat.Type == ChatType.Private)
                        {
                            var session = ctx.Sessions.FirstOrDefault(s => s.ChatId == tgMessage.Chat.Id);

                            // Отправляем сообщение (для групп не важна сессия)
                            if (session != null)
                                await SendMessageFinaly(tgMessage).ConfigureAwait(false);
                            else
                                throw new Exception("Сессия не создана, не получилось отправить сообщение");
                        }
                        else if (tgMessage.Chat.Type == ChatType.Supergroup)
                        {
                            await SendMessageFinaly(tgMessage).ConfigureAwait(false);
                        }
                    }
                }
                catch (Exception ex)
                {
                    _logger.SaveToDb("ОШИБКА! Обработка очереди исходящих сообщений", ex, msgForLog.MessageId);
                }
                finally
                {
                    _mreOutputMsgProcessor.WaitOne(_messageProcessInterval);
                    msgForLog = null;
                }
            }
        }
        

        /// <summary> Добавление сообщения в очередь на отправку </summary>
        public void AddMessageToOutbox(Chat chat, string message, string tag = null, int replyToMessageId = -1)
        {
            var tgMsg = new OutMessage(chat, message) { Tag = tag };
            if (replyToMessageId != -1)
                tgMsg.ReplyToMessageId = replyToMessageId;

            _outputMessageBuffer.Enqueue(tgMsg);
        }
        
        /// <summary> Добавление сообщения в очередь на отправку </summary>
        public void AddMessageToOutbox(long chatId, string message)
        {
            Chat chat = null;

            using (var ctx = new ZsBotContext())
                chat = ctx.Chats.FirstOrDefault(c => c.ChatId == chatId).GetTelegramType();

            var tgMsg = new OutMessage(chat, message);

            _outputMessageBuffer.Enqueue(tgMsg);
        }

        /// <summary> Добавление сообщения в очередь на отправку </summary>
        public void AddMessageToOutbox(string message, params UserRole[] userRoles)
        {
            using var ctx = new ZsBotContext();
            var necessaryUsers = ctx.Users
                                    .Where(u => userRoles.Select(r => $"{r}")
                                    .Contains(u.RoleName))
                                    .ToList();// Для исключения Npgsql.NpgsqlOperationInProgressException: A command is already in progress

            foreach (var user in necessaryUsers)
            {
                var chat = ctx.Chats.FirstOrDefault(c => c.ChatId == user.UserId)
                          ?.GetTelegramType();
                if (chat != null)
                    AddMessageToOutbox(chat, message);
            }
        }

        /// <summary> Удаление сообщения из чата </summary>
        public bool DeleteMessage(long chatId, int messageId)
        {
            try
            {
                _botClient.DeleteMessageAsync(chatId, messageId);

                // Меняем значение IsDeleted в обеих таблицах
                using var ctx = new ZsBotContext();
                var inMsg = ctx.ReceivedMessages.FirstOrDefault(m => m.ChatId == chatId
                                  && m.ReceivedMsgMessageId == messageId);

                var outMsg = ctx.SentMessages.FirstOrDefault(m => m.ChatId == chatId
                                  && m.SentMsgMessageId == messageId);

                if (inMsg != null)
                    inMsg.IsDeleted = true;

                if (outMsg != null)
                    outMsg.IsDeleted = true;

                ctx.SaveChanges();

                return true;
            }
            catch (Exception ex)
            {
                _logger.SaveToDb("ОШИБКА! Удаление сообщения из чата", ex);
                return false;
            }
        }



        /// <summary> Отправка сообщения пользователю (главный, конечный шаг) </summary>
        private async Task SendMessageFinaly(OutMessage tgMessage)
        {
            string tmpFilePath = null;
            try
            {
                Telegram.Bot.Types.Message tmp = null;

                // Определяем тип сообщения, наличие клавиатуры и т.д., а потом уже формируем сообщение и отправляем
                if (tgMessage.Type == Telegram.Bot.Types.Enums.MessageType.Text)
                {
                    // Необходимо, чтобы не словить исключение
                    if (string.IsNullOrWhiteSpace(tgMessage.Text))
                        throw new Exception("Сообщение для пользователя должно содержать хоть какой-то текст!");

                    //if (tgMessage.Message_InlineKeyboard != null)
                    //    await _botClient.SendTextMessageAsync(tgMessage.Chat.Id, $"Пока не умею отсылать сообщения с клавиатурой {tgMessage.GetKeyboardType()}. Сообщите об этом разработчику");
                    //else if (tgMessage.Message_ReplyKeyboard != null)
                    //{
                    //    var markup = GetReplyKeyboardMarkup(tgMessage.Message_ReplyKeyboard);
                    //    await _botClient.SendTextMessageAsync(tgMessage.Chat.Id, tgMessage.Text, ParseMode.Default, replyMarkup: markup);
                    //}
                    //else
                    //    await _botClient.SendTextMessageAsync(tgMessage.Chat.Id, tgMessage.Text, parseMode:ParseMode.Markdown);

                    // Просто отправляем или отправляем ответ на сообщение
                    if (tgMessage.ReplyToMessageId == null || tgMessage.ReplyToMessageId == -1)
                        tmp = new OutMessage(await _botClient.SendTextMessageAsync(tgMessage.Chat.Id, tgMessage.Text, parseMode: ParseMode.Markdown).ConfigureAwait(true));
                    else
                        tmp = new OutMessage(await _botClient.SendTextMessageAsync(tgMessage.Chat.Id, tgMessage.Text, parseMode: ParseMode.Markdown, replyToMessageId: (int)tgMessage.ReplyToMessageId).ConfigureAwait(true));

                }
                else if (tgMessage.Type == Telegram.Bot.Types.Enums.MessageType.Document)
                {
                    //throw new NotImplementedException();
                    //tmpFilePath = GetLocalFileCopy(tgMessage.Message_FilePath);
                    ////Monitor.Enter(_lockObject_SendFile);
                    //using (var fileStream = new FileStream(tmpFilePath, FileMode.Open))
                    //{
                    //    var file = new InputOnlineFile(fileStream);
                    //    await _botClient.SendDocumentAsync(tgMessage.Chat.Id, file, tgMessage.Text);
                    //}
                    ////Monitor.Exit(_lockObject_SendFile);

                }
                else
                {
                    await _botClient.SendTextMessageAsync(tgMessage.Chat.Id, $"Пока не умею отсылать сообщения с типом {tgMessage.Type}. Сообщите об этом разработчику").ConfigureAwait(true);
                }

                // Сохраняем данные сообщения в БД
                if (tmp != null)
                {
                    tgMessage.Parse(tmp);
                    //tgMessage.GetMessageId?.Invoke();
                    tgMessage.IsSentSuccessfully = true;
                    await SaveSentMessageToDb(tgMessage).ConfigureAwait(false);
                }
            }
            catch (Exception ex)
            {
                // Если не удалось отправить сообщения из-за таймаута 
                if (ex is Telegram.Bot.Exceptions.ApiRequestException)
                {// Плохо, но немного лучше чем постоянное дублирование

                    if (tgMessage.FailedSendings > 1)
                    {              // Даём только 2 попытки и выходим
                        try
                        {
                            // Сохраняем данные сообщения в БД
                            tgMessage.IsSentSuccessfully = false;
                            await SaveSentMessageToDb(tgMessage).ConfigureAwait(true);
                        }
                        catch { }

                        //await _logger.SaveExceptionAsync(ex);
                        //_logger.SaveToDb("ОШИБКА! Отправка сообщения", ex, tgMessage?.MessageId);
                        return;
                    }
                    else
                        Thread.Sleep(5000);  // После первого сбоя засыпаем на 5 секунд
                }

                // Пытаемся три раза отправить сообщение, прежде чем вылетит эксепшн
                if (tgMessage.FailedSendings < _trySendLimit)
                {
                    tgMessage.FailDescription = $"{ex.Message}\n{ex.StackTrace}";
                    tgMessage.FailedSendings++;
                    Thread.Sleep(1000 * 2 * tgMessage.FailedSendings);
                    _outputMessageBuffer.Enqueue(tgMessage);
                }
                else
                {
                    try
                    {
                        // Сохраняем данные сообщения в БД
                        tgMessage.IsSentSuccessfully = false;
                        await SaveSentMessageToDb(tgMessage).ConfigureAwait(true);
                        _logger.SaveToDb("Ошибка отправки сообщения", ex);
                    }
                    catch { }

                    //await _logger.SaveExceptionAsync(ex);
                    //_logger.SaveToDb("ОШИБКА! Отправка сообщения", ex);
                }
            }
            finally
            {
                // Убираем мусор
                if (System.IO.File.Exists(tmpFilePath))
                    System.IO.File.Delete(tmpFilePath);
            }

        }
        
        /// <summary> Сохранение сообщения для пользователея в БД </summary>
        private async Task SaveSentMessageToDb(OutMessage tgMessage)
        {
            try
            {
                if (!await DbSentMsg.SaveToDbAsync(tgMessage).ConfigureAwait(true))
                    throw new Exception("Не удалось сохранить исходящее сообщение в БД");
            }
            catch (Exception ex)
            {
                //await _logger.SaveExceptionAsync(ex);
                _logger.SaveToDb("ОШИБКА! Сохранение отправленного сообщения в БД", ex);
            }
        }


    }
}
