using System;
using System.Linq;
using System.Net;
using System.Security.Cryptography;
using System.Text;
using System.Text.Encodings.Web;
using System.Text.Json;
using System.Text.Unicode;
using System.Threading;
using System.Threading.Tasks;
using Telegram.Bot;
using Telegram.Bot.Args;
using Telegram.Bot.Exceptions;
using Telegram.Bot.Types;
using Telegram.Bot.Types.Enums;
using Zs.Bot.Helpers;
using Zs.Bot.Model.Db;
using Zs.Bot.Modules.Messaging;
using Zs.Common.Extensions;
using Zs.Common.Modules;

namespace Zs.Bot.Telegram
{
    public class TelegramMessenger : ModuleBase, Modules.Messaging.IMessenger
    {
        private readonly Logger _logger = Logger.GetInstance();

        // Количество попыток послать сообщение при неудаче
        private readonly int _trySendLimit = 5;

        private TelegramBotClient _botClient;

        private readonly Buffer<InMessage> _inputMessageBuffer = new Buffer<InMessage>();
        private readonly Buffer<OutMessage> _outputMessageBuffer = new Buffer<OutMessage>();

        /// <summary> Обработка сообщений пользователей группового чата (не управляющих сообщений) </summary>
        public event Action<InMessage> GroupChatMessage_Handle;

        public event Action<MessageReceivedEventArgs> MessageReceived;
        public event Action<MessageSentEventArgs> MessageSent;

        // Определяет необходимость сохранения в общий журнал информации от Telegram.Bot API
        public bool ApiLogIsEnabled { get; set; } = false;


        public TelegramMessenger(string token, IWebProxy webProxy = null)
        {
            _inputMessageBuffer.OnEnqueue  += InputMessageBuffer_OnEnqueue;
            _outputMessageBuffer.OnEnqueue += OutputMessageBuffer_OnEnqueue;

            _botClient = webProxy != null
                       ? new TelegramBotClient(token, webProxy)
                       : new TelegramBotClient(token);

            _botClient.IsReceiving = true;
            _botClient.Timeout     = TimeSpan.FromMilliseconds(5000);

            _botClient.ApiResponseReceived   += BotClient_ApiResponseReceived;
            _botClient.OnCallbackQuery       += BotClient_OnCallbackQuery;
            _botClient.OnInlineQuery         += BotClient_OnInlineQuery;
            _botClient.OnInlineResultChosen  += BotClient_OnInlineResultChosen;
            _botClient.OnMessage             += BotClient_OnMessage;
            _botClient.OnMessageEdited       += BotClient_OnMessageEdited;
            _botClient.OnReceiveError        += BotClient_OnReceiveError;
            _botClient.OnReceiveGeneralError += BotClient_OnReceiveGeneralError;
            _botClient.OnUpdate              += BotClient_OnUpdate;

            _botClient.StartReceiving(new UpdateType[]
                {
                    UpdateType.CallbackQuery,
                    UpdateType.ChannelPost,
                    UpdateType.ChosenInlineResult,
                    UpdateType.EditedChannelPost,
                    UpdateType.EditedMessage,
                    UpdateType.InlineQuery,
                    UpdateType.Message,
                    UpdateType.PreCheckoutQuery,
                    UpdateType.ShippingQuery,
                    UpdateType.Unknown
                });
        }

        //public override void Start(int delay)
        //{
        //    try
        //    {
        //        _botClient.StartReceiving(new UpdateType[]
        //        {
        //            UpdateType.CallbackQuery,
        //            UpdateType.ChannelPost,
        //            UpdateType.ChosenInlineResult,
        //            UpdateType.EditedChannelPost,
        //            UpdateType.EditedMessage,
        //            UpdateType.InlineQuery,
        //            UpdateType.Message,
        //            UpdateType.PreCheckoutQuery,
        //            UpdateType.ShippingQuery,
        //            UpdateType.Unknown
        //        });
        //    }
        //    catch (Exception ex)
        //    {
        //        _logger.LogError(ex);
        //    }
        //}

        //public override void Stop(int delay = 0)
        //{
        //    _botClient.StopReceiving();
        //
        //    //// Очистка очередей
        //    //_inputMessageBuffer = new Buffer<InMessage>();
        //    //_outputMessageBuffer = new Buffer<OutMessage>();
        //}

        #region Обработчики событий TelegramBotClient

        private void BotClient_ApiResponseReceived(object sender, ApiResponseEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.LogInfo("ApiResponseReceived", e.ResponseMessage, "Telegram.Bot.API");
        }

        private void BotClient_MakingApiRequest(object sender, ApiRequestEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.LogInfo("MakingApiRequest", e, "Telegram.Bot.API");
        }

        /// <summary> Обработчик нажатия кнопок </summary>
        private void BotClient_OnCallbackQuery(object sender, CallbackQueryEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.LogInfo("OnCallbackQuery", e, "Telegram.Bot.API");
        }

        private void BotClient_OnInlineQuery(object sender, InlineQueryEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.LogInfo("OnInlineQuery", e, "Telegram.Bot.API");
        }

        private void BotClient_OnInlineResultChosen(object sender, ChosenInlineResultEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.LogInfo("OnInlineResultChosen", e, "Telegram.Bot.API");
        }

        /// <summary> Обработчик входящих сообщений</summary>
        private void BotClient_OnMessage(object sender, MessageEventArgs e)
        {
            try
            {
                if (ApiLogIsEnabled)
                    _logger.LogInfo("OnMessage", e, "Telegram.Bot.API");

                _inputMessageBuffer.Enqueue(new InMessage(e.Message));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Не удалось поместить входящее сообщение в буфер. TelegramMessageId={e?.Message?.MessageId}");
            }
        }

        private void BotClient_OnMessageEdited(object sender, MessageEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.LogInfo("OnMessageEdited", e, "Telegram.Bot.API");
        }

        private void BotClient_OnReceiveError(object sender, ReceiveErrorEventArgs e)
        {
            if (e?.ApiRequestException?.Message != "Request timed out")
                _logger.LogInfo("OnReceiveError", e, "Telegram.Bot.API");
        }

        private void BotClient_OnReceiveGeneralError(object sender, ReceiveGeneralErrorEventArgs e)
        {
            if (e.Exception is System.Net.Http.HttpRequestException)
                return;

            _logger.LogInfo("OnReceiveGeneralError", e, "Telegram.Bot.API");
        }

        private void BotClient_OnUpdate(object sender, UpdateEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.LogInfo("OnUpdate", e, "Telegram.Bot.API");
        }

        #endregion
      
        /// <summary> Активация обработчика входящих сообщений </summary>
        private void InputMessageBuffer_OnEnqueue(object sender, InMessage item)
        {
            Task.Run(() => ProcessInputMessages());
        }

        /// <summary> Активация обработчика исходящих сообщений </summary>
        private void OutputMessageBuffer_OnEnqueue(object sender, OutMessage item)
        {
            Task.Run(() => ProcessOutputMessages());
        }
      
        /// <summary> Обработчик очереди входящих сообщений </summary>
        private void ProcessInputMessages()
        {
            InMessage msgForLog = null; // получаем ссылку на сообщение для передачи в лог

            try
            {
                while (_inputMessageBuffer.TryDequeue(out InMessage tgMessage))
                {
                    msgForLog = tgMessage;

                    // Сохраняем данные сообщения
                    //  var dbReceivedMessage = ConvertToReceivedMessage(tgMessage);
                    //  if (!DbReceivedMessage.SaveToDb(dbReceivedMessage))
                    //      throw new InvalidOperationException("Не удалось сохранить входящее сообщение в БД");

                    // Если это групповой чат, то, сохранив сообщение, выходим
                    // НО т.о. бот не будет обрабатывать команды из такого чата
                    if (tgMessage.Chat.Type != ChatType.Private)
                    {
                        GroupChatMessage_Handle?.Invoke(tgMessage);
                        continue;
                    }

                    //0. Находим сессию или создаём новую
                    //DbSession session = null;
                    //using (var ctx = new RobotDbContext())
                    //{
                    //    session = ctx.Sessions.FirstOrDefault(s => s.ChatId == tgMessage.Chat.Id);
                    //
                    //    if (session == null)
                    //    {
                    //        session = new DbSession
                    //        {
                    //            ChatId = tgMessage.Chat.Id,
                    //            SessionIsLoggedIn = false,
                    //            InsertDate = DateTime.Now,
                    //            UpdateDate = DateTime.Now
                    //        };
                    //        ctx.Sessions.Add(session);
                    //        ctx.SaveChanges();
                    //    }
                    //}


                    var args = new MessageReceivedEventArgs()
                    {
                        Message = ToGeneralReceivedMessage(tgMessage),
                        Chat = ToGeneralChat(tgMessage.Chat),
                        User = ToGeneralUser(tgMessage.From)
                    };
                    OnMessageReceived(args);

                    msgForLog = null;
                }
            }
            catch (Exception ex)
            {
                ex.Data.Add("MessageId", msgForLog?.MessageId);
                _logger.LogError(ex);
            }

        }

        /// <summary> Обработчик очереди исходящих сообщений </summary>
        private async Task ProcessOutputMessages()
        {
            OutMessage msgForLog = null;
            try
            {
                while (_outputMessageBuffer.TryDequeue(out OutMessage tgMessage))
                {
                    msgForLog = tgMessage;
                    using var ctx = new RobotDbContext();
                        await SendMessageFinaly(tgMessage).ConfigureAwait(false);

                    msgForLog = null;

                    var args = new MessageSentEventArgs()
                    {
                        Message = ToGeneralSentMessage(tgMessage),
                        Chat = ToGeneralChat(tgMessage.Chat)
                    };
                    OnMessageSent(args);
                }
            }
            catch (Exception ex)
            {
                ex.Data.Add("MessageId", msgForLog?.MessageId);
               _logger.LogError(ex);
            }
        }

        private void OnMessageReceived(MessageReceivedEventArgs args)
        {
            Volatile.Read(ref MessageReceived)?.Invoke(args);
        }

        private void OnMessageSent(MessageSentEventArgs args)
        {
            Volatile.Read(ref MessageSent)?.Invoke(args);
        }



        /// <summary> Добавление сообщения в очередь на отправку </summary>
        private void AddMessageToOutbox(Chat chat, string message, string tag = null, int replyToMessageId = -1)
        {
            var tgMsg = new OutMessage(chat, message) { Tag = tag };
            if (replyToMessageId != -1)
                tgMsg.ReplyToMessageId = replyToMessageId;

            _outputMessageBuffer.Enqueue(tgMsg);
        }

        /// <summary> Удаление сообщения из чата </summary>
        public bool DeleteMessage(long chatId, int messageId)
        {
            try
            {
                //_botClient.DeleteMessageAsync(chatId, messageId);
                //
                //// Меняем значение IsDeleted в обеих таблицах
                //using var ctx = new RobotDbContext();
                //var inMsg = ctx.ReceivedMessages.FirstOrDefault(m => m.ChatId == chatId
                //                  && m.ReceivedMsgMessageId == messageId);
                //
                //var outMsg = ctx.SentMessages.FirstOrDefault(m => m.ChatId == chatId
                //                  && m.SentMsgMessageId == messageId);
                //
                //if (inMsg != null)
                //    inMsg.IsDeleted = true;
                //
                //if (outMsg != null)
                //    outMsg.IsDeleted = true;
                //
                //ctx.SaveChanges();

                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex);
                return false;
            }
        }



        /// <summary> Отправка сообщения пользователю (главный, конечный шаг) </summary>
        private async Task SendMessageFinaly(OutMessage tgMessage)
        {
            string tmpFilePath = null;
            try
            {
                Message tmp = null;

                // Определяем тип сообщения, наличие клавиатуры и т.д., а потом уже формируем сообщение и отправляем
                if (tgMessage.Type == MessageType.Text)
                {
                    // Необходимо, чтобы не словить исключение
                    if (string.IsNullOrWhiteSpace(tgMessage.Text))
                        throw new Exception("Сообщение для пользователя должно содержать хоть какой-то текст!");
                
                    //if (tgMessage.Message_InlineKeyboard != null)
                    //    await _botClient.SendTextMessageAsync(tgMessage.Chat.Id, $"Пока не умею отсылать сообщения с клавиатурой {tgMessage.GetKeyboardType()}. Сообщите об этом разработчику");
                    //else if (tgMessage.Message_ReplyKeyboard != null)
                    //{
                    //    var markup = GetReplyKeyboardMarkup(tgMessage.Message_ReplyKeyboard);
                    //    await _botClient.SendTextMessageAsync(tgMessage.Chat.Id, tgMessage.Text, ParseMode.Default, replyMarkup: markup);
                    //}
                    //else
                    //    await _botClient.SendTextMessageAsync(tgMessage.Chat.Id, tgMessage.Text, parseMode:ParseMode.Markdown);
                
                    // Просто отправляем или отправляем ответ на сообщение
                    if (tgMessage.ReplyToMessageId == null || tgMessage.ReplyToMessageId == -1)
                        tmp = new OutMessage(await _botClient.SendTextMessageAsync(tgMessage.Chat.Id, tgMessage.Text, parseMode: ParseMode.Markdown).ConfigureAwait(true));
                    else
                        tmp = new OutMessage(await _botClient.SendTextMessageAsync(tgMessage.Chat.Id, tgMessage.Text, parseMode: ParseMode.Markdown, replyToMessageId: (int)tgMessage.ReplyToMessageId).ConfigureAwait(true));
                
                }
                else if (tgMessage.Type == MessageType.Document)
                {
                    //throw new NotImplementedException();
                    //tmpFilePath = GetLocalFileCopy(tgMessage.Message_FilePath);
                    ////Monitor.Enter(_lockObject_SendFile);
                    //using (var fileStream = new FileStream(tmpFilePath, FileMode.Open))
                    //{
                    //    var file = new InputOnlineFile(fileStream);
                    //    await _botClient.SendDocumentAsync(tgMessage.Chat.Id, file, tgMessage.Text);
                    //}
                    ////Monitor.Exit(_lockObject_SendFile);
                
                }
                else
                {
                    await _botClient.SendTextMessageAsync(tgMessage.Chat.Id, $"Пока не умею отсылать сообщения с типом {tgMessage.Type}. Сообщите об этом разработчику").ConfigureAwait(true);
                }
                
                // Сохраняем данные сообщения в БД
                if (tmp != null)
                {
                    tgMessage.Parse(tmp);
                    tgMessage.IsSentSuccessfully = true;
                    SaveSentMessageToDb(tgMessage);
                }
            }
            catch (Exception ex)
            {
                // Если не удалось отправить сообщения из-за таймаута 
                if (ex is ApiRequestException)
                {// Плохо, но немного лучше чем постоянное дублирование

                    if (tgMessage.FailedSendings > 1)
                    {              // Даём только 2 попытки и выходим
                        try
                        {
                            // Сохраняем данные сообщения в БД
                            tgMessage.IsSentSuccessfully = false;
                            await SaveSentMessageToDb(tgMessage).ConfigureAwait(true);
                        }
                        catch { }

                        //await _logger.SaveExceptionAsync(ex);
                        //_logger.SaveToDb("ОШИБКА! Отправка сообщения", ex, tgMessage?.MessageId);
                        return;
                    }
                    else
                        Thread.Sleep(5000);  // После первого сбоя засыпаем на 5 секунд
                }

                // Пытаемся три раза отправить сообщение, прежде чем вылетит эксепшн
                if (tgMessage.FailedSendings < _trySendLimit)
                {
                    tgMessage.FailDescription = $"{ex.Message}\n{ex.StackTrace}";
                    tgMessage.FailedSendings++;
                    Thread.Sleep(1000 * 2 * tgMessage.FailedSendings);
                    _outputMessageBuffer.Enqueue(tgMessage);
                }
                else
                {
                    try
                    {
                        // Сохраняем данные сообщения в БД
                        tgMessage.IsSentSuccessfully = false;
                        await SaveSentMessageToDb(tgMessage).ConfigureAwait(true);
                        ex.Data.Add("MessageId", tgMessage?.MessageId);
                        _logger.LogError(ex);
                    }
                    catch { }

                    //await _logger.SaveExceptionAsync(ex);
                    //_logger.SaveToDb("ОШИБКА! Отправка сообщения", ex);
                }
            }
            finally
            {
                // Убираем мусор
                if (System.IO.File.Exists(tmpFilePath))
                    System.IO.File.Delete(tmpFilePath);
            }

        }
      
        /// <summary> Сохранение сообщения для пользователея в БД </summary>
        private async Task SaveSentMessageToDb(OutMessage tgMessage)
        {
            //try
            //{
            //    await DbSentMsg.SaveToDbAsync(tgMessage)
            //}
            //catch (Exception ex)
            //{
            //    _logger.LogError(ex);
            //}
        }

        public void AddMessageToOutbox(IChat chat, string messageText, string tag = null, int replyToMessageId = -1)
        {
            throw new NotImplementedException();
        }

        public void AddMessageToOutbox(string messageText, params string[] userRoleCodes)
        {
            using var ctx = new RobotDbContext();
            var users = ctx.Users.Where(u => userRoleCodes.Contains(u.UserRoleCode))
                                 .ToList();// Для исключения Npgsql.NpgsqlOperationInProgressException: A command is already in progress

            var chats = ctx.Chats.Where(c => users.Select(u => u.UserId).Contains(c.ChatId)).ToList();

            var tgChats = chats.Select(c => JsonSerializer.Deserialize<Chat>(c.RawData));
            
            foreach (var chat in tgChats)
                _outputMessageBuffer.Enqueue(new OutMessage(chat, messageText));

            //var testTgChat = new Chat()
            //{
            //    Id = 210281448
            //};
            //_outputMessageBuffer.Enqueue(new OutMessage(testTgChat, messageText));
        }

        public IReceivedMessage ToGeneralReceivedMessage(object specificMessage)
        {
            var options = new JsonSerializerOptions();
            options.IgnoreNullValues = true;
            options.WriteIndented = true;
            options.Encoder = JavaScriptEncoder.Create(UnicodeRanges.All);

            if (specificMessage is Message telegramMessage)
            {
                var receivedMessage = DbEntityFactory.NewReceivedMessage();
                var msgText = telegramMessage.Text?.Length > 100 
                            ? telegramMessage.Text.Substring(0, 100)
                            : telegramMessage.Text;

                // receivedMessage.ReceivedMessageId -> Auto
                //sentMessage.ChatId        -> define when saving
                //sentMessage.UserId        -> define when saving
                receivedMessage.MessengerCode = "TG";
                receivedMessage.MessageTypeCode = GetGeneralMessageTypeCode(telegramMessage.Type);
                receivedMessage.ReceivedMessageText = msgText;
                receivedMessage.RawData = JsonSerializer.Serialize(telegramMessage, options);
                
                return receivedMessage;
            }
            else
                throw new InvalidCastException($"{nameof(specificMessage)} is not a {typeof(Message).FullName}");
        }
        public ISentMessage ToGeneralSentMessage(object specificMessage)
        {
            var options = new JsonSerializerOptions();
            options.IgnoreNullValues = true;
            options.WriteIndented = true;
            options.Encoder = JavaScriptEncoder.Create(UnicodeRanges.All);

            if (specificMessage is Message telegramMessage)
            {
                var sentMessage = DbEntityFactory.NewSentMessage();
                var msgText = telegramMessage.Text?.Length > 100
                            ? telegramMessage.Text.Substring(0, 100)
                            : telegramMessage.Text;

                //sentMessage.SentMessageId -> Auto
                //sentMessage.ChatId        -> define when saving
                sentMessage.MessengerCode = "TG";
                sentMessage.MessageTypeCode = GetGeneralMessageTypeCode(telegramMessage.Type);
                sentMessage.SentMessageText = msgText;
                sentMessage.RawData = JsonSerializer.Serialize(telegramMessage, options);

                return sentMessage;
            }
            else
                throw new InvalidCastException($"{nameof(specificMessage)} is not a {typeof(Message).FullName}");
        }

        public IChat ToGeneralChat(object specificChat)
        {
            var options = new JsonSerializerOptions();
            options.IgnoreNullValues = true;
            options.WriteIndented = true;
            options.Encoder = JavaScriptEncoder.Create(UnicodeRanges.All);

            if (specificChat is Chat telegramChat)
            {
                var chat = DbEntityFactory.NewChat();

                
                //chat.ChatId -> Auto
                chat.ChatDescription = telegramChat.Description;
                chat.ChatTitle = telegramChat.Title ?? telegramChat.Username ?? $"{telegramChat.FirstName} {telegramChat.LastName}";
                chat.ChatTypeCode = GetGeneralChatTypeCode(telegramChat.Type);
                chat.RawData = JsonSerializer.Serialize(telegramChat, options);
                chat.RawDataHash = chat.RawData.GetMD5Hash();

                return chat;
            }
            else
                throw new InvalidCastException($"{nameof(specificChat)} is not a {typeof(Chat).FullName}");
        }

        public IUser ToGeneralUser(object specificUser)
        {
            var options = new JsonSerializerOptions();
            options.IgnoreNullValues = true;
            options.WriteIndented = true;
            options.Encoder = JavaScriptEncoder.Create(UnicodeRanges.All);

            if (specificUser is User telegramUser)
            {
                var user = DbEntityFactory.NewUser();

                //user.UserId -> Auto
                user.UserRoleCode = "USER";
                user.UserName = telegramUser.Username;
                user.UserFullName = $"{telegramUser.FirstName} {telegramUser.LastName}";
                user.UserIsBot = telegramUser.IsBot;
                user.RawData = JsonSerializer.Serialize(telegramUser, options);
                user.RawDataHash = user.RawData.GetMD5Hash();

                return user;
            }
            else
                throw new InvalidCastException($"{nameof(specificUser)} is not a {typeof(User).FullName}");
        }

        private string GetGeneralChatTypeCode(ChatType type)
        {
            return type switch
            {
                ChatType.Channel    => "CHANNEL",
                ChatType.Group      => "GROUP",
                ChatType.Private    => "PRIVATE",
                ChatType.Supergroup => "GROUP",
                _ => "UKNOWN"
            };
        }

        private string GetGeneralMessageTypeCode(MessageType type)
        {
            return type switch
            {
                MessageType.Text     => "TXT",
                MessageType.Photo    => "PHT",
                MessageType.Audio    => "AUD",
                MessageType.Video    => "VID",
                MessageType.Voice    => "VOI",
                MessageType.Document => "DOC",
                MessageType.Sticker  => "STK",
                MessageType.Location => "LOC",
                MessageType.Contact  => "CNT",

                var o when
                o == MessageType.Venue ||
                o == MessageType.Game ||
                o == MessageType.VideoNote ||
                o == MessageType.Invoice ||
                o == MessageType.SuccessfulPayment ||
                o == MessageType.WebsiteConnected ||
                o == MessageType.Animation ||
                o == MessageType.Poll ||
                o == MessageType.Dice => "OTH",

                var s when
                s == MessageType.ChatMembersAdded ||
                s == MessageType.ChatMemberLeft ||
                s == MessageType.ChatTitleChanged ||
                s == MessageType.ChatPhotoChanged ||
                s == MessageType.MessagePinned ||
                s == MessageType.ChatPhotoDeleted ||
                s == MessageType.GroupCreated ||
                s == MessageType.SupergroupCreated ||
                s == MessageType.ChannelCreated ||
                s == MessageType.MigratedToSupergroup ||
                s == MessageType.MigratedFromGroup => "SRV",

                _ => "UKN"
            };
        }

    }
}
