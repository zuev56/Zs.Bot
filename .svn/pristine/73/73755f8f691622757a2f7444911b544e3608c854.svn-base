using System;
using System.Linq;
using System.Net;
using System.Threading;
using System.Threading.Tasks;
using Newtonsoft.Json;
using Telegram.Bot;
using Telegram.Bot.Args;
using Telegram.Bot.Exceptions;
using Telegram.Bot.Types;
using Telegram.Bot.Types.Enums;
using Zs.Bot.Helpers;
using Zs.Bot.Model.Db;
using Zs.Bot.Modules.Messaging;
using Zs.Common.Enums;
using Zs.Common.Modules;

namespace Zs.Bot.Telegram
{
    public class TelegramMessenger : ModuleBase, Modules.Messaging.IMessenger
    {
        private readonly Logger _logger = Logger.GetInstance();
        private readonly int _sendingRetryLimit = 5;
        private readonly TelegramBotClient _botClient;
        private readonly Buffer<InMessage> _inputMessageBuffer = new Buffer<InMessage>();
        private readonly Buffer<OutMessage> _outputMessageBuffer = new Buffer<OutMessage>();

        public event Action<MessageReceivedEventArgs> MessageEdited;
        public event Action<MessageReceivedEventArgs> MessageReceived; 
        public event Action<MessageReceivedEventArgs> GroupMessageReceived;
        public event Action<MessageReceivedEventArgs> ChannelMessageReceived;
        public event Action<MessageSentEventArgs> MessageSent;
        public event Action<MessageDeletedEventArgs> MessageDeleted;
        public bool ApiLogIsEnabled { get; set; } = false;
        public IToGenegalItemConverter ItemConverter { get; set; } = new ItemConverter();


        public TelegramMessenger(string token, IWebProxy webProxy = null)
        {
            _inputMessageBuffer.OnEnqueue  += InputMessageBuffer_OnEnqueue;
            _outputMessageBuffer.OnEnqueue += OutputMessageBuffer_OnEnqueue;

            _botClient = webProxy != null
                       ? new TelegramBotClient(token, webProxy)
                       : new TelegramBotClient(token);

            _botClient.IsReceiving = true;
            _botClient.Timeout = TimeSpan.FromSeconds(5);

            _botClient.ApiResponseReceived   += BotClient_ApiResponseReceived;
            _botClient.OnCallbackQuery       += BotClient_OnCallbackQuery;
            _botClient.OnInlineQuery         += BotClient_OnInlineQuery;
            _botClient.OnInlineResultChosen  += BotClient_OnInlineResultChosen;
            _botClient.OnMessage             += BotClient_OnMessage;
            _botClient.OnMessageEdited       += BotClient_OnMessageEdited;
            _botClient.OnReceiveError        += BotClient_OnReceiveError;
            _botClient.OnReceiveGeneralError += BotClient_OnReceiveGeneralError;
            _botClient.OnUpdate              += BotClient_OnUpdate;

            _botClient.StartReceiving(new UpdateType[]
            {
                UpdateType.Unknown,
                UpdateType.Message,
                UpdateType.InlineQuery,
                UpdateType.ChosenInlineResult,
                UpdateType.CallbackQuery,
                UpdateType.EditedMessage,
                UpdateType.ChannelPost,
                UpdateType.EditedChannelPost,
                UpdateType.ShippingQuery,
                UpdateType.PreCheckoutQuery,
                UpdateType.Poll, 
                UpdateType.PollAnswer
            });
#if DEBUG
            ApiLogIsEnabled = true;
#endif
        }


        #region Обработчики событий TelegramBotClient

        private void BotClient_ApiResponseReceived(object sender, ApiResponseEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.LogInfo("ApiResponseReceived", e.ResponseMessage, "Telegram.Bot.API");
        }

        private void BotClient_MakingApiRequest(object sender, ApiRequestEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.LogInfo("MakingApiRequest", e, "Telegram.Bot.API");
        }

        private void BotClient_OnCallbackQuery(object sender, CallbackQueryEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.LogInfo("OnCallbackQuery", e, "Telegram.Bot.API");
        }

        private void BotClient_OnInlineQuery(object sender, InlineQueryEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.LogInfo("OnInlineQuery", e, "Telegram.Bot.API");
        }

        private void BotClient_OnInlineResultChosen(object sender, ChosenInlineResultEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.LogInfo("OnInlineResultChosen", e, "Telegram.Bot.API");
        }

        private void BotClient_OnMessage(object sender, MessageEventArgs e)
        {
            try
            {
                if (ApiLogIsEnabled)
                    _logger.LogInfo("OnMessage", e, "Telegram.Bot.API");

                _inputMessageBuffer.Enqueue(new InMessage(e.Message));
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Не удалось поместить входящее сообщение в буфер. TelegramMessageId={e?.Message?.MessageId}");
            }
        }

        private void BotClient_OnMessageEdited(object sender, MessageEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.LogInfo("OnMessageEdited", e, "Telegram.Bot.API");

            _inputMessageBuffer.Enqueue(new InMessage(e.Message) { IsEdited = true });
        }

        private void BotClient_OnReceiveError(object sender, ReceiveErrorEventArgs e)
        {
            if (e?.ApiRequestException?.Message != "Request timed out")
                _logger.LogInfo("OnReceiveError", e, "Telegram.Bot.API");
        }

        private void BotClient_OnReceiveGeneralError(object sender, ReceiveGeneralErrorEventArgs e)
        {
            if (e.Exception is System.Net.Http.HttpRequestException)
                return;

            _logger.LogInfo("OnReceiveGeneralError", e, "Telegram.Bot.API");
        }

        private void BotClient_OnUpdate(object sender, UpdateEventArgs e)
        {
            if (ApiLogIsEnabled)
                _logger.LogInfo("OnUpdate", e, "Telegram.Bot.API");
        }

        #endregion
      
        private void InputMessageBuffer_OnEnqueue(object sender, InMessage item)
        {
            Task task = null;
            task = Task.Run(() => ProcessInputMessages(task));
        }

        private void OutputMessageBuffer_OnEnqueue(object sender, OutMessage item)
        {
            Task task = null;
            task = Task.Run(() => ProcessOutputMessages(task));
        }
      
        private void ProcessInputMessages(Task currentTask)
        {
            InMessage msgForLog = null;

            try
            {
                while (_inputMessageBuffer.TryDequeue(out InMessage tgMessage))
                {
                    msgForLog = tgMessage;

                    var args = new MessageReceivedEventArgs()
                    {
                        Message = ItemConverter.ToGeneralReceivedMessage(tgMessage),
                        Chat    = ItemConverter.ToGeneralChat(tgMessage.Chat),
                        User    = ItemConverter.ToGeneralUser(tgMessage.From)
                    };

                    if (tgMessage.IsEdited)
                    {
                        OnMessageEdited(args);
                        continue;
                    }

                    OnMessageReceived(args);

                    if (tgMessage.Chat.Type == ChatType.Group 
                        || tgMessage.Chat.Type == ChatType.Supergroup)
                        OnGroupMessageReceived(args);

                    if (tgMessage.Chat.Type == ChatType.Channel)
                        OnChannelMessageReceived(args);

                    msgForLog = null;
                }
            }
            catch (Exception ex)
            {
                ex.Data.Add("MessageId", msgForLog?.MessageId);
                _logger.LogError(ex);
            }
        }

        private void ProcessOutputMessages(Task currentTask)
        {
            OutMessage msgForLog = null;
            try
            {
                while (_outputMessageBuffer.TryDequeue(out OutMessage tgMessage))
                {
                    msgForLog = tgMessage;
                    OperationResult sendingResult;

                    using var ctx = new RobotDbContext();
                    sendingResult = SendMessageFinaly(tgMessage, currentTask);

                    if (sendingResult == OperationResult.Retry)
                        continue;

                    var args = new MessageSentEventArgs()
                    {
                        Message = ItemConverter.ToGeneralSentMessage(tgMessage),
                        Chat    = ItemConverter.ToGeneralChat(tgMessage.Chat)
                    };
                    OnMessageSent(args);

                    msgForLog = null;
                }
            }
            catch (Exception ex)
            {
                ex.Data.Add("MessageId", msgForLog?.MessageId);
               _logger.LogError(ex);
            }
        }

        public void AddMessageToOutbox(IChat chat, string messageText, IReceivedMessage messageToReply = null)
        {
            try
            {
                if (chat is null)
                    throw new ArgumentNullException(nameof(chat));

                if (string.IsNullOrEmpty(messageText))
                    throw new ArgumentNullException(nameof(messageText), "Message must have a body!");

                var tgChat = System.Text.Json.JsonSerializer.Deserialize<Chat>(chat.RawData);
                var tgMessage = System.Text.Json.JsonSerializer.Deserialize<Message>(messageToReply.RawData);

                var msg = new OutMessage(tgChat, messageText)
                {
                    ReplyToMessageId = tgMessage.MessageId
                };

                _outputMessageBuffer.Enqueue(msg);
            }
            catch (Exception e)
            {
                _logger.LogError(e);
                throw;
            }
        }

        public void AddMessageToOutbox(string messageText, params string[] userRoleCodes)
        {
            using var ctx = new RobotDbContext();
            var users = ctx.Users.Where(u => userRoleCodes.Contains(u.UserRoleCode))
                                 .ToList();// Для исключения Npgsql.NpgsqlOperationInProgressException: A command is already in progress

            var chats = ctx.Chats.Where(c => users.Select(u => u.UserId).Contains(c.ChatId)).ToList();

            var tgChats = chats.Select(c => System.Text.Json.JsonSerializer.Deserialize<Chat>(c.RawData));

            foreach (var chat in tgChats)
                _outputMessageBuffer.Enqueue(new OutMessage(chat, messageText));
        }

        public OperationResult DeleteMessage(IChat chat, IReceivedMessage message)
        {
            try
            {
                if (chat == null)
                    throw new ArgumentNullException(nameof(chat));

                if (message == null)
                    throw new ArgumentNullException(nameof(message));

                var tgChat = System.Text.Json.JsonSerializer.Deserialize<Chat>(chat.RawData);
                var tgMessage = System.Text.Json.JsonSerializer.Deserialize<Message>(message.RawData);
                
                _botClient.DeleteMessageAsync(tgChat.Id, tgMessage.MessageId).GetAwaiter().GetResult();

                message.IsDeleted = true;
                var args = new MessageDeletedEventArgs()
                {
                    Chat = chat,
                    Message = message
                };

                OnMessageDeleted(args);

                return OperationResult.Success;
            }
            catch (Exception e)
            {
                _logger.LogError(e);
                return OperationResult.Failure;
            }
        }

        private OperationResult SendMessageFinaly(OutMessage message, Task currentTask)
        {
            try
            {
                Message tgMessage = null;

                switch (message.Type)
                {
                    case MessageType.Text:
                        if (string.IsNullOrWhiteSpace(message.Text))
                            throw new Exception("Text message have no text");

                        Message tmp = message.ReplyToMessageId is null
                                ? _botClient.SendTextMessageAsync(
                                    message.Chat.Id,
                                    message.Text,
                                    ParseMode.Markdown).GetAwaiter().GetResult()
                                : _botClient.SendTextMessageAsync(
                                    message.Chat.Id,
                                    message.Text,
                                    ParseMode.Markdown,
                                    replyToMessageId: (int)message.ReplyToMessageId).GetAwaiter().GetResult();
                        tgMessage = new OutMessage(tmp);
                        break;
                    default:
                        _botClient.SendTextMessageAsync(
                                  message.Chat.Id,
                                  $"Unable to send message type of {message.Type} "
                                  ).GetAwaiter().GetResult();
                        break;
                }

                
                // Сохраняем данные сообщения в БД
                if (tgMessage != null)
                {
                    message.Parse(tgMessage);
                    message.IsSentSuccessfully = true;
                }

                return OperationResult.Success;
            }
            catch (Exception e)
            {
                if (e is ApiRequestException)
                {
                    if (message.SendingFails > 1)
                    {
                        message.IsSentSuccessfully = false;
                        return OperationResult.Failure;
                    }
                    else
                        currentTask.Wait(3000);
                }

                if (message.SendingFails < _sendingRetryLimit)
                {
                    message.FailDescription = JsonConvert.SerializeObject(e, Formatting.Indented);
                    message.SendingFails++;
                    currentTask.Wait(2000 * message.SendingFails);
                    _outputMessageBuffer.Enqueue(message);
                    return OperationResult.Retry;
                }
                else
                {
                    try
                    {
                        message.IsSentSuccessfully = false;
                        e.Data.Add("Message", message);
                        _logger.LogError(e);
                        return OperationResult.Failure;
                    }
                    catch { return OperationResult.Failure; }
                }
            }
        }


        private void OnMessageEdited(MessageReceivedEventArgs args)
        {
            Volatile.Read(ref MessageEdited)?.Invoke(args);
        }
        private void OnMessageReceived(MessageReceivedEventArgs args)
        {
            Volatile.Read(ref MessageReceived)?.Invoke(args);
        }
        private void OnGroupMessageReceived(MessageReceivedEventArgs args)
        {
            Volatile.Read(ref GroupMessageReceived)?.Invoke(args);
        }
        private void OnChannelMessageReceived(MessageReceivedEventArgs args)
        {
            Volatile.Read(ref ChannelMessageReceived)?.Invoke(args);
        }
        private void OnMessageSent(MessageSentEventArgs args)
        {
            Volatile.Read(ref MessageSent)?.Invoke(args);
        }
        private void OnMessageDeleted(MessageDeletedEventArgs args)
        {
            Volatile.Read(ref MessageDeleted)?.Invoke(args);
        }
        
    }
}
